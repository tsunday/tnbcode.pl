+++
categories = ["python"]
comments = false
date = "2018-07-18T16:59:13-00:00"
draft = false
showpagemeta = true
showcomments = true
slug = ""
tags = ["python", "python3.7", "coding", "software"]
title = "Python 3.7 - developer's choice"
description = "Python 3.7 comes with few interesting features and many performance improvements"

+++

## Intro

Python 3.7 comes with few interesting features and many performance improvements. In short words, you can find there:

- new `breakpoint()` function,
- `async`/`await` as reserved keywords,
- module level `__getattr__` and `__dir__` methods
- nanosecond resolution in `time` functions
- postponed evaluation of type hints (annotations)
- context variables
- data classes

In this note I'm going to take deep insight into data classes. In my opinion this is the most important change in our latest Python version.

## Why data classes are great

Data classes allow to write more consistent and meaningful code. As other cool features in Python like e.g. generators, they provide new syntax for describing thinking processes more compactly and with less lines of code. This is what makes Python awesome (`import this`).

## Let's get to the point

Data classes provide new class decorator that can be used with classes to represent data structures. They came to the standard library with a new `dataclasses` module:
```
from dataclasses import dataclass
```

### Simple data class

```
@dataclass
class City:
  citizens: int
  area: float

krakow = City(767, 326)

print(krakow)

> City(citizens=767, area=326)
```
With this 4-lines class declaration, we get automatically created `__init__` and `__repr__` function definitions.

### Ordered data classes

Morover we can also define ordered data structures and compare if needed:

```
@dataclass(order=True)
class City:
  name: str = field(compare=False)
  citizens: int
  area: float

zamosc = City('Zamość', 65, 30)
krakow = City('Kraków', 767, 326)
ochock = City('Ochock', 3, 400)


bigger = zamosc if zamosc > krakow else krakow
print(f'Bigger city: {bigger}')
print(sorted([zamosc, krakow, ochock]))

> Bigger city: City(name='Kraków', citizens=767, area=326)
> [City(name='Ochock', citizens=3, area=400), City(name='Zamość', citizens=65, area=30), City(name='Kraków', citizens=767, area=326)]
```

With this example we've just introduced new `field` function (from `dataclasses` module). It allows to override default behavior of the class for a single field - in this case we can disable ordering based on city names.

As you can see, we can also sort data objects with `sorted`. What's interesting here, is that class attributes ordering matters - in this case `citizen` is the significant parameter.

### Default `dataclass` parameters

By default, dataclass decorator is set up with given list of parameters:

```
@dataclass(init=True, repr=True, eq=True, order=False, unsafe_hash=False, frozen=False)
```

They correspond to autogenerated methods like `__init__`, `__repr__`, `__eq__`, `__hash__` and ordering helpers (`__lt__`, `__le__`, `__gt__`, and `__ge__`), so you have control over what's acutally being generated in specific case. `frozen` parameter allows to create immutable objects.

### Inheritance

Data classes can be inherited by child-classes. Let's see what is the ordering of the resulted class attributes.

```
@dataclass
class A:
  x: int = 1
  y: int = 2


@dataclass
class B(A):
  z: int = 3
  x: int = 5

print(A())
print(B())
print(B(0, 1, 2))
> A(x=1, y=2)
> B(x=5, y=2, z=3)
> B(x=0, y=1, z=2)
```

Field ordering from the base class is preserved.

### Last but not least

```
@dataclass
class Product:
  size: int
  quantity: int
  price: float

p = Product(10, 1, 1.23)
print(asdict(p))

> {'size': 10, 'quantity': 1, 'price': 1.23}
```

Whoa! We've just introduced JSON serialization of Python object with just few lines of code - it wasn't that trivial before (see [this](https://stackoverflow.com/a/3768975) and [this](https://medium.com/the-python-corner/object-serialization-in-python-1d49c6ad071)). With `asdict` `dataclasses` module level function, you can just get `dict` representation of data structure hold by given data class. Just send it over your favourite API framework ;)

## Reference
https://www.python.org/dev/peps/pep-0557/
https://docs.python.org/3/whatsnew/3.7.html
https://realpython.com/python37-new-features/
https://docs.python.org/3/reference/index.html